<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>視覚的に改善された3D家系図</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background-color: #f8f9fa;
            color: #333;
        }
        #canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: none;
            transition: all 0.3s ease;
            max-height: 80vh;
            overflow-y: auto;
        }
        .info-panel h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 22px;
            font-weight: 600;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }
        .info-label {
            font-weight: 600;
            color: #7f8c8d;
            margin-bottom: 4px;
            font-size: 14px;
        }
        .info-value {
            margin-bottom: 15px;
            line-height: 1.4;
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            border: none;
            background: none;
            font-size: 18px;
            cursor: pointer;
            color: #95a5a6;
            transition: color 0.2s;
        }
        .close-btn:hover {
            color: #e74c3c;
        }
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 15px 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-width: 250px;
            font-size: 14px;
        }
        .instructions h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
        }
        .instructions ul {
            padding-left: 20px;
            margin: 0;
        }
        .instructions li {
            margin-bottom: 5px;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .loading h2 {
            color: #2c3e50;
            margin-bottom: 5px;
            font-weight: 600;
        }
        .loading p {
            color: #7f8c8d;
            margin-top: 5px;
        }
        .loading .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .tooltip {
            position: absolute;
            background-color: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 100;
            max-width: 200px;
            text-align: center;
        }
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        .legend h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
        }
        .color-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
        }
        .relationship-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .line {
            width: 30px;
            height: 3px;
            margin-right: 10px;
        }
        .control-button {
            background-color: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.2s;
            position: absolute;
            z-index: 10;
        }
        .control-button:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
        }
        .reset-view {
            top: 20px;
            left: 20px;
        }
        .reset-view svg {
            width: 20px;
            height: 20px;
            fill: #3498db;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <h2>家系図を読み込み中...</h2>
        <p>しばらくお待ちください</p>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <button class="control-button reset-view" id="reset-view" title="視点をリセット">
        <svg viewBox="0 0 24 24">
            <path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/>
        </svg>
    </button>
    
    <div class="info-panel" id="info-panel">
        <button class="close-btn" id="close-info">×</button>
        <h2 id="person-name">名前</h2>
        <div class="info-label">世代</div>
        <div class="info-value" id="person-generation"></div>
        <div class="info-label">親</div>
        <div class="info-value" id="person-parents"></div>
        <div class="info-label">配偶者</div>
        <div class="info-value" id="person-spouse"></div>
        <div class="info-label">子</div>
        <div class="info-value" id="person-children"></div>
        <div class="info-label">追加情報</div>
        <div class="info-value" id="person-info"></div>
    </div>
    
    <div class="instructions">
        <h3>操作方法</h3>
        <ul>
            <li><b>回転</b>: ドラッグ</li>
            <li><b>ズーム</b>: スクロール</li>
            <li><b>移動</b>: 右クリック+ドラッグ</li>
            <li><b>選択</b>: クリック</li>
            <li><b>人物の移動</b>: ダブルクリック→そのまま移動</li>
            <li><b>リセット</b>: 左上のボタン</li>
        </ul>
        <p>※橙色の小さな点が夫婦の接続点です。<br>そこから子供へのラインが伸びています。</p>
    </div>
    
    <div class="legend">
        <h3>凡例</h3>
        <div class="color-item">
            <div class="color-box" style="background-color: #4682B4;"></div>
            <span>祖父母世代</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background-color: #DB7093;"></div>
            <span>父母世代</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background-color: #20B2AA;"></div>
            <span>自分世代</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background-color: #FFA500; opacity: 0.7; border-radius: 50%;"></div>
            <span>夫婦の接続点</span>
        </div>
        <div class="relationship-item">
            <div class="line" style="background-color: #FFA500;"></div>
            <span>夫婦関係</span>
        </div>
        <div class="relationship-item">
            <div class="line" style="background-color: #27ae60;"></div>
            <span>親子関係</span>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <!-- Three.jsを読み込む -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- OrbitControlsを読み込む - 修正済み -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Three.jsの読み込みを待ってから初期化
        window.addEventListener('load', function() {
            // Three.jsの読み込みを確認
            if (typeof THREE === 'undefined') {
                alert('Three.jsライブラリの読み込みに失敗しました。ページを再読み込みしてください。');
                document.getElementById('loading').innerHTML = '<h2>エラー: Three.jsの読み込みに失敗しました</h2><p>ページを再読み込みしてください。</p>';
                return;
            }

            // OrbitControlsの読み込みを確認
            if (typeof THREE.OrbitControls === 'undefined') {
                alert('OrbitControlsの読み込みに失敗しました。ページを再読み込みしてください。');
                document.getElementById('loading').innerHTML = '<h2>エラー: OrbitControlsの読み込みに失敗しました</h2><p>ページを再読み込みしてください。</p>';
                return;
            }

            // 初期化処理を開始
            init();
        });

        function createEdgeFromPoint(startPoint, endPosition, color, type) {
            // 点とノードの間にエッジを作成
            
            // 中間点の計算（カーブを付ける場合）
            let points;
            
            if (type === 'parent-child') {
                // 親子関係の場合、カーブを付ける
                const midPoint = new THREE.Vector3(
                    (startPoint.x + endPosition.x) / 2,
                    (startPoint.y + endPosition.y) / 2 - 10, // 少し下に湾曲
                    (startPoint.z + endPosition.z) / 2
                );
                
                // 曲線に沿った点を生成
                const curve = new THREE.QuadraticBezierCurve3(
                    startPoint.clone(),
                    midPoint,
                    endPosition.clone()
                );
                
                points = curve.getPoints(20);
            } else {
                // それ以外の場合は直線
                points = [startPoint.clone(), endPosition.clone()];
            }
            
            // ジオメトリの作成
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            // マテリアルの設定
            const material = new THREE.LineBasicMaterial({ 
                color: color,
                linewidth: 1
            });
            
            // 線のメッシュを作成
            const edge = new THREE.Line(geometry, material);
            scene.add(edge);
            
            // エッジの参照を保存
            edges.push({
                line: edge,
                startPoint: startPoint.clone(),
                endPosition: endPosition.clone(),
                type: type,
                isFromPoint: true, // 点から始まるエッジであることを示すフラグ
                endNode: null // 終点のノードがある場合はここに保存
            });
            
            // 終点が実際のノードの場合
            Object.values(nodes).forEach(node => {
                if (node.position.distanceTo(endPosition) < 0.1) { // 位置が近ければ同じと判断
                    const edgeIndex = edges.length - 1;
                    edges[edgeIndex].endNode = node;
                }
            });
        }

        function init() {
            // 家系図データ
            const familyData = [
                { id: 1, name: "祖父", generation: 0, info: "1920年生まれ。元軍人で厳格な性格だった。第二次世界大戦に従軍。退役後は地域の活動に尽力し、多くの人から尊敬されていた。" },
                { id: 2, name: "祖母", generation: 0, info: "1925年生まれ。温かく家族想いの人だった。料理が得意で、特に伝統的な和菓子作りに優れていた。地域の文化祭では毎年腕を振るっていた。" },
                { id: 3, name: "父", generation: 1, info: "1950年生まれ。会社経営者。自分の会社を一から立ち上げ、成功させた。仕事熱心だが家族サービスも忘れない。趣味は釣りと庭いじり。" },
                { id: 4, name: "叔父", generation: 1, info: "1945年生まれ。医師として活躍。地域医療に貢献し、多くの患者から信頼されている。研究論文も多数発表。休日は山登りを楽しむ。" },
                { id: 5, name: "母", generation: 1, info: "1952年生まれ。教師を長く務めた。生徒からの信頼も厚く、退職後も多くの元生徒が連絡を取り合う。絵画が趣味で、自宅の壁には彼女の作品が飾られている。" },
                { id: 6, name: "自分", generation: 2, info: "1985年生まれ。IT企業でエンジニアとして働いている。新しい技術を学ぶことが好きで、休日はプログラミングや電子工作を楽しむ。" },
                { id: 7, name: "兄", generation: 2, info: "1980年生まれ。海外で働いている。グローバル企業のマネージャーとして活躍中。3カ国語を話すことができ、世界各地を飛び回っている。" },
                { id: 8, name: "姉", generation: 2, info: "1982年生まれ。デザイナーとして活躍中。有名ブランドのデザインを手がけ、その才能は業界でも高く評価されている。二児の母でもある。" },
                { id: 9, name: "いとこ1", generation: 2, info: "1975年生まれ。公務員。真面目で責任感が強く、市役所で管理職を務めている。地域貢献にも熱心で、ボランティア活動にも参加。" },
                { id: 10, name: "いとこ2", generation: 2, info: "1978年生まれ。小学校教師。子どもたちから大人気の先生。創造的な授業が評判で、教育関係の賞も受賞している。" },
            ];

            // 家族関係のデータ
            const relationships = [
                // 夫婦関係
                { type: 'spouse', source: 1, target: 2 },
                { type: 'spouse', source: 3, target: 5 },
                // 親子関係
                { type: 'parent-child', parent: 1, child: 3 },
                { type: 'parent-child', parent: 1, child: 4 },
                { type: 'parent-child', parent: 2, child: 3 },
                { type: 'parent-child', parent: 2, child: 4 },
                { type: 'parent-child', parent: 3, child: 6 },
                { type: 'parent-child', parent: 3, child: 7 },
                { type: 'parent-child', parent: 3, child: 8 },
                { type: 'parent-child', parent: 5, child: 6 },
                { type: 'parent-child', parent: 5, child: 7 },
                { type: 'parent-child', parent: 5, child: 8 },
                { type: 'parent-child', parent: 4, child: 9 },
                { type: 'parent-child', parent: 4, child: 10 },
            ];

            // グローバル変数を宣言
            window.scene = new THREE.Scene();
            window.nodes = {};
            window.edges = [];
            
            // 背景をグラデーションにする
            const canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            const gradient = context.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#e6f2ff');
            gradient.addColorStop(1, '#f0f8ff');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 2, 512);
            const texture = new THREE.CanvasTexture(canvas);
            scene.background = texture;

            const camera = new THREE.PerspectiveCamera(
                60, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.z = 200;

            const renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // OrbitControlsの設定 - 修正済み
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.2;
            controls.screenSpacePanning = true; // 画面空間パンニングを有効に（上下移動をよりスムーズに）
            controls.minDistance = 100;
            controls.maxDistance = 400;
            controls.maxPolarAngle = Math.PI / 1.5;
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };
            
            // 光源の追加
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
            backLight.position.set(-10, 5, -10);
            scene.add(backLight);

            // 世代ごとの色
            const generationColors = [
                0x4682B4, // 祖父母世代（スティールブルー）
                0xDB7093, // 父母世代（パレオバイオレットレッド）
                0x20B2AA  // 自分世代（ライトシーグリーン）
            ];

            // ノードの作成
            familyData.forEach(person => {
                // 球体のジオメトリとマテリアル
                const geometry = new THREE.SphereGeometry(5, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(generationColors[person.generation] || 0xffffff),
                    shininess: 100,
                    specular: 0x111111,
                    emissive: 0x000000
                });
                
                // メッシュの作成
                const mesh = new THREE.Mesh(geometry, material);
                
                // 世代に基づいて位置を設定
                const yPos = -person.generation * 50;
                const angle = Math.random() * Math.PI * 2;
                const radius = 30 + Math.random() * 20;
                const xPos = Math.cos(angle) * radius;
                const zPos = Math.sin(angle) * radius;
                
                mesh.position.set(xPos, yPos, zPos);
                
                // メッシュにデータを関連付け
                mesh.userData = {
                    id: person.id,
                    name: person.name,
                    generation: person.generation,
                    info: person.info,
                    originalColor: new THREE.Color(generationColors[person.generation] || 0xffffff),
                    isSelected: false
                };
                
                // シーンに追加
                scene.add(mesh);
                
                // ノードの参照を保存
                nodes[person.id] = mesh;
                
                // 名前ラベルの作成（Three.jsのCanvasで作成）
                const labelCanvas = document.createElement('canvas');
                const context = labelCanvas.getContext('2d');
                
                // 適切なサイズに設定
                const fontSize = 14;
                context.font = `${fontSize}px Arial, sans-serif`;
                const textWidth = context.measureText(person.name).width;
                
                labelCanvas.width = textWidth + 20;
                labelCanvas.height = fontSize + 10;
                
                // 背景と枠を描画
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.strokeStyle = '#cccccc';
                context.lineWidth = 1;
                
                // 角丸の矩形
                const cornerRadius = 4;
                context.beginPath();
                context.moveTo(cornerRadius, 0);
                context.lineTo(labelCanvas.width - cornerRadius, 0);
                context.quadraticCurveTo(labelCanvas.width, 0, labelCanvas.width, cornerRadius);
                context.lineTo(labelCanvas.width, labelCanvas.height - cornerRadius);
                context.quadraticCurveTo(labelCanvas.width, labelCanvas.height, labelCanvas.width - cornerRadius, labelCanvas.height);
                context.lineTo(cornerRadius, labelCanvas.height);
                context.quadraticCurveTo(0, labelCanvas.height, 0, labelCanvas.height - cornerRadius);
                context.lineTo(0, cornerRadius);
                context.quadraticCurveTo(0, 0, cornerRadius, 0);
                context.closePath();
                
                context.fill();
                context.stroke();
                
                // テキストを描画
                context.fillStyle = '#333333';
                context.font = `${fontSize}px Arial, sans-serif`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(person.name, labelCanvas.width / 2, labelCanvas.height / 2);
                
                // テクスチャを作成
                const texture = new THREE.CanvasTexture(labelCanvas);
                const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                const label = new THREE.Sprite(labelMaterial);
                label.scale.set(labelCanvas.width / 5, labelCanvas.height / 5, 1);
                label.position.y = 9; // ノードの上に配置
                
                // ラベルをノードの子要素として追加
                mesh.add(label);
            });

            // エッジの作成
            // 夫婦の中間点を保存するオブジェクト
            const coupleNodes = {};
            
            // まず夫婦関係を作成して中間点を計算
            relationships.forEach(rel => {
                if (rel.type === 'spouse') {
                    const sourceNode = nodes[rel.source];
                    const targetNode = nodes[rel.target];
                    
                    if (sourceNode && targetNode) {
                        // 夫婦関係を作成
                        createEdge(sourceNode, targetNode, 0xFFA500, rel.type);
                        
                        // 夫婦の中間点を計算して保存
                        const coupleId = `${rel.source}-${rel.target}`;
                        const midPoint = new THREE.Vector3();
                        midPoint.addVectors(sourceNode.position, targetNode.position).multiplyScalar(0.5);
                        
                        // 中間点のビジュアル表現（小さい球体）を作成
                        const couplerGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                        const couplerMaterial = new THREE.MeshPhongMaterial({
                            color: 0xFFA500,
                            shininess: 100,
                            transparent: true,
                            opacity: 0.7
                        });
                        const couplerMesh = new THREE.Mesh(couplerGeometry, couplerMaterial);
                        couplerMesh.position.copy(midPoint);
                        scene.add(couplerMesh);
                        
                        // 中間点の参照を保存
                        coupleNodes[coupleId] = {
                            point: midPoint,
                            mesh: couplerMesh,
                            source: sourceNode,
                            target: targetNode
                        };
                    }
                }
            });
            
            // 夫婦ノードの位置が変わったときの中間点更新関数を定義
            function updateCoupleNodes() {
                for (const coupleId in coupleNodes) {
                    const couple = coupleNodes[coupleId];
                    const sourcePos = couple.source.position;
                    const targetPos = couple.target.position;
                    
                    // 中間点位置を再計算
                    couple.point.copy(sourcePos).add(targetPos).multiplyScalar(0.5);
                    couple.mesh.position.copy(couple.point);
                }
            }
            
            // 次に親子関係を作成（中間点から子供へ）
            relationships.forEach(rel => {
                if (rel.type === 'parent-child') {
                    const parentNode = nodes[rel.parent];
                    const childNode = nodes[rel.child];
                    
                    if (parentNode && childNode) {
                        // 親が含まれる夫婦関係を探す
                        let coupleNode = null;
                        
                        for (const coupleId in coupleNodes) {
                            const couple = coupleNodes[coupleId];
                            if (couple.source === parentNode || couple.target === parentNode) {
                                coupleNode = couple;
                                break;
                            }
                        }
                        
                        if (coupleNode) {
                            // 中間点から子供へのエッジを作成
                            createEdgeFromPoint(coupleNode.point, childNode.position, 0x27ae60, 'parent-child');
                        } else {
                            // 中間点が見つからない場合は直接親から子へ
                            createEdge(parentNode, childNode, 0x27ae60, 'parent-child');
                        }
                    }
                }
            });

            function createEdge(source, target, color, type) {
                // エッジの座標を計算
                const sourcePos = source.position;
                const targetPos = target.position;
                
                // 中間点の計算（カーブを付ける場合）
                let points;
                
                if (type === 'parent-child') {
                    // 親子関係の場合、カーブを付ける
                    const midPoint = new THREE.Vector3(
                        (sourcePos.x + targetPos.x) / 2,
                        (sourcePos.y + targetPos.y) / 2 - 10, // 少し下に湾曲
                        (sourcePos.z + targetPos.z) / 2
                    );
                    
                    // 曲線に沿った点を生成
                    const curve = new THREE.QuadraticBezierCurve3(
                        sourcePos.clone(),
                        midPoint,
                        targetPos.clone()
                    );
                    
                    points = curve.getPoints(20);
                } else {
                    // 夫婦関係の場合は直線
                    points = [sourcePos.clone(), targetPos.clone()];
                }
                
                // ジオメトリの作成
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // マテリアルの設定
                const material = new THREE.LineBasicMaterial({ 
                    color: color,
                    linewidth: 1
                });
                
                // 線のメッシュを作成
                const edge = new THREE.Line(geometry, material);
                scene.add(edge);
                
                // エッジの参照を保存
                edges.push({
                    line: edge,
                    source: source,
                    target: target,
                    type: type
                });
            }

            // ドラッグ状態の管理
            let isDragging = false;
            let draggedNode = null;
            let dragStartPosition = new THREE.Vector3();
            let dragPlane = new THREE.Plane();
            let mousePosition = new THREE.Vector2();
            let raycaster = new THREE.Raycaster();
            let selectedNode = null;

            // マウスの位置を追跡
            function updateMousePosition(event) {
                mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
                mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }

            // ドラッグとダブルクリックに関する変数
            let lastClickTime = 0;
            let isDraggingNode = false;
            let draggableNode = null;
            let dragStartY = 0; // ドラッグ開始時のY座標を保存
            let currentPlane = new THREE.Plane(); // ドラッグ用の平面
            
            // マウスイベントのハンドラー
            function onMouseDown(event) {
                updateMousePosition(event);
                
                // 右クリックの場合は処理しない（OrbitControlsに任せる）
                if (event.button === 2) {
                    return;
                }
                
                // レイキャストでノードを検出
                raycaster.setFromCamera(mousePosition, camera);
                const intersects = raycaster.intersectObjects(Object.values(nodes));
                
                if (intersects.length > 0) {
                    // ノードをクリック
                    const clickedNode = intersects[0].object;
                    
                    // 現在の時間を取得
                    const currentTime = new Date().getTime();
                    const isDoubleClick = (currentTime - lastClickTime < 300);
                    lastClickTime = currentTime;
                    
                    // 以前に選択されたノードがあれば選択解除
                    if (selectedNode && selectedNode !== clickedNode) {
                        selectedNode.material.emissive.setHex(0x000000);
                        selectedNode.scale.set(1, 1, 1);
                        selectedNode.userData.isSelected = false;
                    }
                    
                    // 新しいノードを選択
                    selectedNode = clickedNode;
                    selectedNode.material.emissive.setHex(0x333333);
                    selectedNode.scale.set(1.2, 1.2, 1.2);
                    selectedNode.userData.isSelected = true;
                    
                    // 情報パネルを表示
                    showInfoPanel(selectedNode.userData);
                    
                    // ダブルクリックの場合はドラッグモードを開始
                    if (isDoubleClick) {
                        isDraggingNode = true;
                        draggableNode = clickedNode;
                        dragStartY = clickedNode.position.y; // Y座標を保存
                        
                        // ドラッグ用の平面を作成（カメラの向きに垂直な平面）
                        const normal = new THREE.Vector3().subVectors(camera.position, draggableNode.position).normalize();
                        currentPlane.setFromNormalAndCoplanarPoint(normal, draggableNode.position);
                        
                        // カメラコントロールを一時停止
                        controls.enabled = false;
                        
                        // ノードの色を変更して移動中であることを示す
                        draggableNode.material.emissive.setHex(0x00ff00);
                    }
                    
                    event.preventDefault();
                } else {
                    // 何もクリックしていない場合、情報パネルを閉じて選択解除
                    if (selectedNode) {
                        selectedNode.material.emissive.setHex(0x000000);
                        selectedNode.scale.set(1, 1, 1);
                        selectedNode.userData.isSelected = false;
                        selectedNode = null;
                    }
                    
                    document.getElementById('info-panel').style.display = 'none';
                }
            }

            function onMouseMove(event) {
                updateMousePosition(event);
                
                // ツールチップの処理
                raycaster.setFromCamera(mousePosition, camera);
                const intersects = raycaster.intersectObjects(Object.values(nodes));
                
                const tooltip = document.getElementById('tooltip');
                
                if (intersects.length > 0) {
                    const node = intersects[0].object;
                    tooltip.textContent = node.userData.name;
                    tooltip.style.left = event.clientX + 10 + 'px';
                    tooltip.style.top = event.clientY + 10 + 'px';
                    tooltip.style.opacity = 1;
                } else {
                    tooltip.style.opacity = 0;
                }
                
                // ノードのドラッグ処理
                if (isDraggingNode && draggableNode) {
                    // レイキャストでマウス位置の3D空間上の点を計算
                    raycaster.setFromCamera(mousePosition, camera);
                    
                    // レイとドラッグ平面の交点を計算
                    const intersectPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(currentPlane, intersectPoint);
                    
                    // ノードを移動（Y座標は固定）
                    draggableNode.position.x = intersectPoint.x;
                    draggableNode.position.z = intersectPoint.z;
                    draggableNode.position.y = dragStartY; // Y座標を元の値に維持
                    
                    // 関連するエッジを更新
                    updateEdges();
                    
                    event.preventDefault();
                }
            }

            function onMouseUp(event) {
                // ノードドラッグの終了処理
                if (isDraggingNode && draggableNode) {
                    // 移動中の色から選択色に戻す
                    draggableNode.material.emissive.setHex(0x333333);
                    
                    isDraggingNode = false;
                    draggableNode = null;
                    
                    // OrbitControlsを再度有効化
                    controls.enabled = true;
                    
                    event.preventDefault();
                }
            }

            // エッジを更新する関数
            function updateEdges() {
                // 通常のエッジを更新
                edges.forEach(edge => {
                    const line = edge.line;
                    
                    // 既存の線を削除
                    scene.remove(line);
                    
                    // 新しい線を作成
                    if (edge.isFromPoint) {
                        // 点から始まるエッジの場合
                        const startPoint = edge.startPoint;
                        const endPosition = edge.endNode ? edge.endNode.position : edge.endPosition;
                        const type = edge.type;
                        
                        let points;
                        
                        if (type === 'parent-child') {
                            // 親子関係の場合、カーブを付ける
                            const midPoint = new THREE.Vector3(
                                (startPoint.x + endPosition.x) / 2,
                                (startPoint.y + endPosition.y) / 2 - 10, // 少し下に湾曲
                                (startPoint.z + endPosition.z) / 2
                            );
                            
                            // 曲線に沿った点を生成
                            const curve = new THREE.QuadraticBezierCurve3(
                                startPoint.clone(),
                                midPoint,
                                endPosition.clone()
                            );
                            
                            points = curve.getPoints(20);
                        } else {
                            // それ以外の場合は直線
                            points = [startPoint.clone(), endPosition.clone()];
                        }
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = line.material.clone();
                        
                        edge.line = new THREE.Line(geometry, material);
                    } else {
                        // 通常のエッジの場合
                        const source = edge.source;
                        const target = edge.target;
                        const type = edge.type;
                        
                        if (type === 'parent-child') {
                            // 親子関係の場合、カーブを付ける
                            const midPoint = new THREE.Vector3(
                                (source.position.x + target.position.x) / 2,
                                (source.position.y + target.position.y) / 2 - 10, // 少し下に湾曲
                                (source.position.z + target.position.z) / 2
                            );
                            
                            // 曲線に沿った点を生成
                            const curve = new THREE.QuadraticBezierCurve3(
                                source.position.clone(),
                                midPoint,
                                target.position.clone()
                            );
                            
                            const points = curve.getPoints(20);
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const material = line.material.clone();
                            
                            edge.line = new THREE.Line(geometry, material);
                        } else {
                            // 夫婦関係の場合は直線
                            const points = [source.position.clone(), target.position.clone()];
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const material = line.material.clone();
                            
                            edge.line = new THREE.Line(geometry, material);
                        }
                    }
                    
                    scene.add(edge.line);
                });
                
                // 夫婦の中間点も更新
                updateCoupleNodes();
            }

            // 情報パネルを表示する関数
            function showInfoPanel(personData) {
                const panel = document.getElementById('info-panel');
                document.getElementById('person-name').textContent = personData.name;
                
                let generationText = '';
                switch(personData.generation) {
                    case 0: generationText = '祖父母世代'; break;
                    case 1: generationText = '父母世代'; break;
                    case 2: generationText = '自分世代'; break;
                    default: generationText = `第${personData.generation}世代`;
                }
                document.getElementById('person-generation').textContent = generationText;
                
                // 親を探す
                const parents = [];
                relationships.forEach(rel => {
                    if (rel.type === 'parent-child' && rel.child === personData.id) {
                        const parent = familyData.find(p => p.id === rel.parent);
                        if (parent) {
                            parents.push(parent.name);
                        }
                    }
                });
                
                document.getElementById('person-parents').textContent = parents.length > 0 ? parents.join(', ') : '情報なし';
                
                // 子を探す
                const children = [];
                relationships.forEach(rel => {
                    if (rel.type === 'parent-child' && rel.parent === personData.id) {
                        const child = familyData.find(c => c.id === rel.child);
                        if (child) {
                            children.push(child.name);
                        }
                    }
                });
                
                document.getElementById('person-children').textContent = children.length > 0 ? children.join(', ') : '情報なし';
                
                // 配偶者を探す
                const spouses = [];
                relationships.forEach(rel => {
                    if (rel.type === 'spouse') {
                        let spouseId = null;
                        if (rel.source === personData.id) {
                            spouseId = rel.target;
                        } else if (rel.target === personData.id) {
                            spouseId = rel.source;
                        }
                        
                        if (spouseId) {
                            const spouse = familyData.find(p => p.id === spouseId);
                            if (spouse) {
                                spouses.push(spouse.name);
                            }
                        }
                    }
                });
                
                document.getElementById('person-spouse').textContent = spouses.length > 0 ? spouses.join(', ') : '情報なし';
                document.getElementById('person-info').textContent = personData.info || '情報なし';
                
                panel.style.display = 'block';
            }

            // ウィンドウのリサイズ対応
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            // 情報パネルを閉じるボタン
            document.getElementById('close-info').addEventListener('click', function() {
                document.getElementById('info-panel').style.display = 'none';
                
                if (selectedNode) {
                    selectedNode.material.emissive.setHex(0x000000);
                    selectedNode.scale.set(1, 1, 1);
                    selectedNode.userData.isSelected = false;
                    selectedNode = null;
                }
            });
            
            // 視点をリセットするボタン
            document.getElementById('reset-view').addEventListener('click', function() {
                // カメラの位置をリセット
                camera.position.set(0, 0, 200);
                camera.lookAt(0, 0, 0);
                controls.update();
            });

            // イベントリスナーを設定
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('contextmenu', function(event) { event.preventDefault(); });

            // カメラを原点に向ける
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            // レンダリングループ
            function animate() {
                requestAnimationFrame(animate);
                
                // OrbitControlsの更新
                controls.update();
                
                renderer.render(scene, camera);
            }

            // ローディング画面を非表示
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1000);

            // アニメーションスタート
            animate();
        }
    </script>
</body>
</html>